#+TITLE: DotEmacs
#+AUTHOR: Richard Sent
#+PROPERTY: header-args :results silent :tangle yes

This is my personal Emacs configuration, now with 100% more =Org=!

* Installation

I'll write this up later.

* Configuration

** Meta

Much of this section was +stolen+ borrowed from [[https://github.com/larstvei/dot-emacs][larstvei]].

All changes to the configuration should be done in =init.org=, *not* in
=init.el=. Any changes in the =init.el= will be overwritten by saving
=init.org=. The =init.el= in this repo should not be tracked by git, and
is replaced the first time Emacs is started (assuming it has been renamed
to =~/.emacs.d=).

Emacs can't load =.org=-files directly, but =org-mode= provides functions
to extract the code blocks and write them to a file. There are multiple
ways of handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]], one
could just use =org-babel-load-file=, but I had problems with
byte-compilation. Previously I tracked both the =org.=- and =el.=-files,
but the git commits got a little messy. So here is a new approach.

When this configuration is loaded for the first time, the =init.el= is
the file that is loaded. It looks like this:

#+BEGIN_SRC emacs-lisp :tangle no
  ;; This file replaces itself with the actual configuration at first run.

  ;; We can't tangle without org!
  (require 'org)
  ;; Open the configuration
  (find-file (concat user-emacs-directory "init.org"))
  ;; tangle it
  (org-babel-tangle)
  ;; load it
  (load-file (concat user-emacs-directory "init.el"))
  ;; finally byte-compile it
  (byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

It tangles the org-file, so that this file is overwritten with the actual
configuration.

There is no reason to track the =init.el= that is generated; by running
the following command =git= will not bother tracking it:

#+BEGIN_SRC sh :tangle no
  git update-index --assume-unchanged init.el
#+END_SRC

If one wishes to make changes to the repo-version of =init.el= start
tracking again with:

#+BEGIN_SRC sh :tangle no
  git update-index --no-assume-unchanged init.el
#+END_SRC

I want lexical scoping for the init-file, which can be specified in the
header. The first line of the configuration is as follows:

#+BEGIN_SRC emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+END_SRC

The =init.el= should (after the first run) mirror the source blocks in
the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which
extracts the code blocks from the current file into a source-specific
file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to
the =after-save-hook= ensuring to always tangle and byte-compile the
=org=-document after changes.

#+BEGIN_SRC emacs-lisp
  (defun my/tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are
  tangled, and the tangled file is compiled."
    (when (equal (buffer-file-name)
		 (expand-file-name (concat user-emacs-directory "init.org")))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
	(org-babel-tangle)
	(byte-compile-file (concat user-emacs-directory "init.el")))))

  (add-hook 'after-save-hook 'my/tangle-init)
#+END_SRC

** Basics

*** Speedup

We want to keep the garbage collector from running while we initialize
everything. We can reset it later to a more reasonable value. If we
didn't do this, Emacs would hang when running the garbage collector.

#+begin_src emacs-lisp
  (setq-default
   gc-cons-threshold most-positive-fixnum ; 8 MiB
   gc-cons-percentage 0.6)
#+end_src

Replace the file-name-handler-alist to nil, as regexing is cpu
intensive. We need to keep the original value to restore it later. I
don't know all the details behind it, but it sounds helpful!

#+begin_src emacs-lisp
  (defvar default-file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)
#+end_src

And now we revert the changes with a startup hook. 16777216 is the
value Doom uses.

#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold 16777216
                    gc-cons-percentage 0.1
                    file-name-handler-alist default-file-name-handler-alist)))
#+end_src

Garbage-collect on focus-out. Emacs /should/ feel snappier overall.
With Emacs 27.1, focus-out-hook is deprecated.

#+BEGIN_SRC emacs-lisp
  (add-function :after after-focus-change-function (unless (frame-focus-state) #'garbage-collect))
#+END_SRC

Apparently this can result in a significant speedup when using fonts
larger or smaller than the system default.

#+begin_src emacs-lisp
  (setq frame-inhibit-implied-resize t)
#+end_src

*** Sensible Defaults

I don't need no fancy user interface! These ones are only active when
in a window. Apparently putting this in ~early-init.el~ will speed up
startup even more.

#+begin_src emacs-lisp
  (push '(menu-bar-lines . 1) default-frame-alist)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)
#+end_src

And now for a bunch of one liner configurations.

#+begin_src emacs-lisp
  (setq-default
   auth-source-save-behavior nil                 ; Not interested in auth-source
   frame-resize-pixelwise t                      ; Removes empty space at bottom of screen when maximized
   help-window-select t                          ; Select help windows when they appear
   inhibit-startup-screen t                      ; Emacs really could use a more "welcoming" welcome screen
   initial-scratch-message ""                    ; Clear scratch buffer
   next-screen-context-lines 6                   ; Keep 6 lines of context when using scroll-up/down-command
   ring-bell-function 'ignore                    ; My ears!
   scroll-conservatively most-positive-fixnum    ; Always scroll by one line
   scroll-preserve-screen-position t             ; Try to keep point in the same location visually
   sentence-end-double-space nil                 ; Use a single space after dots
   show-help-function nil                        ; Disable help text on most UI elements
   uniquify-buffer-name-style 'forward           ; Make buffer names unique
   use-dialog-box nil                            ; Apparently compile reverting buffers counts as a mouse command
   )
  (defalias 'yes-or-no-p 'y-or-n-p)              ; y is shorter than yes
  (delete-selection-mode 1)                      ; If I selected something, I probably want to edit it.
  (global-auto-revert-mode 1)                    ; If I edit something elsewhere, I probably want to reload
  (global-hl-line-mode)                          ; Highlight the active line
  (menu-bar-mode 0)                              ; Disable the menu bar
  (set-default-coding-systems 'utf-8)            ; Default to utf-8 encoding
#+end_src

Start Emacs in fullscreen.

#+BEGIN_SRC emacs-lisp
  (if (eq window-system 'ns)
      (set-frame-parameter nil 'fullscreen 'maximized)
    (set-frame-parameter nil 'fullscreen 'fullboth))
#+END_SRC

I already know about Emacs, thank you.

#+begin_src emacs-lisp
  (fset 'display-startup-echo-area-message 'ignore)
#+end_src

**** Disabled Commands

While I could use ~(setq disabled-command-function nil)~, I'd prefer to
disable them piecemeal in the off-chance there's a disabled command I
actually want to be disabled.

#+begin_src emacs-lisp
  (put 'downcase-region 'disabled nil)           ; Is it really that confusing?
  (put 'erase-buffer 'disabled nil)              ; It's literally in the name
  (put 'upcase-region 'disabled nil)             ; I reiterate. Is it really that confusing?
#+end_src

*** Autosaves and Backups

Don't randomly litter my filesystem with autosaves and backups.

#+begin_src emacs-lisp
  (setq
;   auto-save-file-name-transforms                           ; 
;   `((".*" ,(concat user-emacs-directory "autosaves/") t))  ; still don't litter my fs tree
   backup-by-copying t                                      ; don't clobber symlinks
   backup-directory-alist                                   ; 
   `(("." . ,(concat user-emacs-directory "backups")))      ; don't litter my fs tree
   delete-old-versions t                                    ; 
   kept-new-versions 6                                      ; 
   kept-old-versions 2                                      ; 
   version-control t)                                       ; use versioned backups
#+end_src

*Especially* don't litter remote servers!

#+begin_src emacs-lisp
  (setq
   tramp-auto-save-directory                                ; don't litter remote machines 
   (concat user-emacs-directory "autosaves")                ;
   tramp-backup-directory-alist backup-directory-alist)     ; still don't litter remote machines 
#+end_src

*** ~custom.el~ Support

I have no desire for appending autogenerated elisp to =init.el=. I'd
much rather concentrate that into a single file that I call
=custom.el=. If one doesn't already exist, I want to create a blank
one.

#+BEGIN_SRC emacs-lisp
  (write-region "" "" (expand-file-name "custom.el" (file-name-directory (or load-file-name buffer-file-name))) t)
  (setq-default custom-file (expand-file-name "custom.el" (file-name-directory (or load-file-name buffer-file-name))))
  (load custom-file)
#+END_SRC

*** Constants

A slowly growing list of constants. Many of these are thanks to
[[https://github.com/seagle0128/.emacs.d][Centaur Emacs]].

#+begin_src emacs-lisp
  (defconst sys/win32p                    ; I hope I don't need this constant
    (eq system-type 'windows-nt)
    "Are we running on a WinTel system?")

  (defconst sys/linuxp
    (eq system-type 'gnu/linux)
    "Are we running on a GNU/Linux system?")

  (defconst sys/macp
    (eq system-type 'darwin)
    "Are we running on a Mac system?")

  (defconst sys/mac-x-p
    (and (display-graphic-p) sys/macp)
    "Are we running under X on a Mac system?")

  (defconst sys/mac-ns-p
    (eq window-system 'ns)
    "Are we running on a GNUstep or Macintosh Cocoa display?")

  (defconst sys/mac-cocoa-p
    (featurep 'cocoa)
    "Are we running with Cocoa on a Mac system?")

  (defconst sys/mac-port-p
    (eq window-system 'mac)
    "Are we running a macport build on a Mac system?")

  (defconst sys/linux-x-p
    (and (display-graphic-p) sys/linuxp)
    "Are we running under X on a GNU/Linux system?")

  (defconst sys/cygwinp
    (eq system-type 'cygwin)
    "Are we running on a Cygwin system?")

  (defconst sys/rootp
    (string-equal "root" (getenv "USER"))
    "Are you using ROOT user?")

  (defconst emacs/>=25p
    (>= emacs-major-version 25)
    "Emacs is 25 or above.")

  (defconst emacs/>=26p
    (>= emacs-major-version 26)
    "Emacs is 26 or above.")

  (defconst emacs/>=27p
    (>= emacs-major-version 27)
    "Emacs is 27 or above.")

  (defconst emacs/>=25.3p
    (or emacs/>=26p
	(and (= emacs-major-version 25) (>= emacs-minor-version 3)))
    "Emacs is 25.3 or above.")

  (defconst emacs/>=25.2p
    (or emacs/>=26p
	(and (= emacs-major-version 25) (>= emacs-minor-version 2)))
    "Emacs is 25.2 or above.")
#+end_src

*** Bootstrap

**** Straight Bootstrap

I use [[https://github.com/raxod502/straight.el][straight.el]] for package management. This is boostrap code from
the Github repo to set up straight.

#+begin_src emacs-lisp
  (defvar straight-fix-flycheck t)
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
  (straight-use-package 'use-package)      ; Install use-package
  (setq straight-use-package-by-default t) ; I don't want to type :straight t a billion times
#+end_src

**** Bind-keys Bootstrap

I'm not entirely sure why this is necessary, and more importantly,
what better solutions there are. But when byte-compiling Emacs,
bind-keys isn't properly loaded by use-package. This means any
custom (and most built-in) keybindings are nonfunctional.

Solution found [[https://old.reddit.com/r/emacs/comments/c6fvvr/unable_to_initialize_package_with_usepackage/es92xjd/][here]].

#+begin_src emacs-lisp
  (use-package bind-key
    :config
    (add-to-list 'same-window-buffer-names "*Personal Keybindings*"))
#+end_src

** Functions

Custom functions from various sources.

*** Org Heading Fontification

Code and explanations from [[https://reddit.com/r/emacs/comments/cw0499/prevent_folded_headings_from_bleeding_out/][/u/ouroboroslisp]] ([[https://web.archive.org/web/20190925072833/https://www.reddit.com/r/emacs/comments/cw0499/prevent_folded_headings_from_bleeding_out/][archive)]] to try and fix
font lock face bleeding out into org headings if there's only one
space. This is most common with source code blocks, although it's not
visible to everyone as some themes may have the same face for source
code blocks and the background.

I've disabled these functions for now since they didn't appear to help
at all with this init.org file. Instead, I found
=org-fontify-whole-block-delimiter-line= and set that to nil.

Unfontify the last line of a subtree if it's the end of a source
block. This is the line responsible for the bleeding.

#+begin_src emacs-lisp
  ;; (defun dwim-unfontify-last-line-of-subtree (&rest _)
  ;;   "Unfontify last line of subtree if it's a source block."
  ;;   (save-excursion
  ;;     (org-end-of-subtree)
  ;;     (beginning-of-line)
  ;;     (when (looking-at-p (rx "#+end_src"))
  ;;       (font-lock-unfontify-region
  ;;        (line-end-position) (1+ (line-end-position))))))

  ;; (advice-add #'outline-hide-subtree :after #'dwim-unfontify-last-line-of-subtree)
#+end_src

Now we need to refontify that line at the right time. There’s two
things we need to account for. We need to make sure that the
=#+end_src= line is fontified when it’s visible. Also we should keep
in mind that any newly revealed (ie. By unfolding subtree with
outline-toggle-children) folded source block headings are also
bleeders and need to have their =#+end_src= unfontified also.

It’s also important which functions we choose to advice or modify for
this because we want to minimize the amount of work we want to do.
Ideally, we’d like a pretty core function so that this behavior would
propagate to other functions.

Looking at the source for =outline-toggle-children=, I thought
=outline-show-heading= was a good choice to advise. Keeping all this in
mind I wrote this advising function.

#+begin_src emacs-lisp
  ;; (defun dwim-fontify-last-line-of-block (&rest _)
  ;;   "Do what I mean: fontify last line of source block.
  ;;  When the heading has a source block as the last item (in the subtree) do the
  ;;    following:
  ;;  If the source block is now visible, fontify the end its last line.
  ;;  If it’s still invisible, unfontify its last line."
  ;;   (let (font-lock-fn point)
  ;;     (save-excursion
  ;;       (org-end-of-subtree)
  ;;       (beginning-of-line)
  ;;       (run-hooks 'outline-view-change-hook)
  ;;       (when (looking-at-p (rx "#+end_src"))
  ;; 	(setq font-lock-fn
  ;; 	      (if (invisible-p (line-end-position))
  ;; 		  #'font-lock-unfontify-region
  ;; 		#'font-lock-fontify-region))
  ;; 	(funcall font-lock-fn
  ;; 		 (line-end-position)
  ;; 		 (1+ (line-end-position)))))))

  ;; (advice-add #'outline-show-heading :after #'dwim-fontify-last-line-of-block)
#+end_src

*** Sort words
Sort words in region alphabetically. If arg is negative, sort them in
reverse.

#+begin_src emacs-lisp
  (defun sort-words (reverse beg end)
    "Sort words in region alphabetically, in REVERSE if negative.
  Prefixed with negative \\[universal-argument], sorts in reverse.

  The variable `sort-fold-case' determines whether alphabetic case
  affects the sort order.

  See `sort-regexp-fields'."
    (interactive "*P\nr")
    (sort-regexp-fields reverse "\\w+" "\\&" beg end))
#+end_src

*** Packages

Functions used by packages I have installed.

Return t if a font is installed, nil otherwise. Used by
=all-the-icons=.

#+begin_src emacs-lisp
  (defun aorst/font-installed-p (font-name)
    "Check if font with FONT-NAME is available."
    (if (find-font (font-spec :name font-name))
        t
      nil))
#+end_src

A duo of functions for getting human readable file sizes. Used by
=ibuffer-vc=.

#+begin_src emacs-lisp
  (defun ajv/human-readable-file-sizes-to-bytes (string)
    "Convert a human-readable file size into bytes."
    (interactive)
    (cond
     ((string-suffix-p "G" string t)
      (* 1000000000 (string-to-number (substring string 0 (- (length string) 1)))))
     ((string-suffix-p "M" string t)
      (* 1000000 (string-to-number (substring string 0 (- (length string) 1)))))
     ((string-suffix-p "K" string t)
      (* 1000 (string-to-number (substring string 0 (- (length string) 1)))))
     (t
      (string-to-number (substring string 0 (- (length string) 1))))
     )
    )
  (defun ajv/bytes-to-human-readable-file-sizes (bytes)
    "Convert number of bytes to human-readable file size."
    (interactive)
    (cond
     ((> bytes 1000000000) (format "%10.1fG" (/ bytes 1000000000.0)))
     ((> bytes 100000000) (format "%10.0fM" (/ bytes 1000000.0)))
     ((> bytes 1000000) (format "%10.1fM" (/ bytes 1000000.0)))
     ((> bytes 100000) (format "%10.0fk" (/ bytes 1000.0)))
     ((> bytes 1000) (format "%10.1fk" (/ bytes 1000.0)))
     (t (format "%10d" bytes)))
    )
#+end_src

** UI

*** Icons

| =all-the-icons=       | https://github.com/domtronn/all-the-icons.el  |
| =all-the-icons-dired= | https://github.com/jtbm37/all-the-icons-dired |

I like having pretty icons next to a lot of things. I also don't like
remembering to install them on a new machine.

#+begin_src emacs-lisp
  (use-package all-the-icons
    :config
    (when (and (not (aorst/font-installed-p "all-the-icons"))
               (window-system))
      (all-the-icons-install-fonts t))
    :defer 1)
#+end_src

I also like having them in dired.

#+begin_src emacs-lisp
  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

*** Themes

| =doom-themes= | https://github.com/hlissner/emacs-doom-themes |

Why install one theme when many will do? Yeah, that sounds right.

#+begin_src emacs-lisp
  (use-package doom-themes
    :config (load-theme 'doom-nord t))
#+end_src

*** Fontq

I like being able to see the text on my screen.

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(font . "Fira Code-11"))
#+end_src

*** Ibuffer

| =all-the-icons-ibuffer= | https://github.com/seagle0128/all-the-icons-ibuffer |
| =ibuffer-vc=            | https://github.com/purcell/ibuffer-vc               |

First and foremost, replace =list-buffers= with =Ibuffer=

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

Next, I'll set up some pretty icons.

#+begin_src emacs-lisp
  (use-package all-the-icons-ibuffer
    :diminish
    :after all-the-icons)
#+end_src

Time to actually make =Ibuffer= functional by setting up automatic version
control groups.

FIXME: Currently the ~*Help*~ buffer is not properly aligned with the others.

#+begin_src emacs-lisp
  (use-package ibuffer-vc ; Also consider ibuffer-projectile
    :after all-the-icons-ibuffer
    :hook (ibuffer . (lambda () (ibuffer-vc-set-filter-groups-by-vc-root) ; Look at combining with custom ibuffer groups with 'ibuffer-projectile-generate-filter-groups
                       (unless (eq ibuffer-sorting-mode 'alphabetic)      ; Obviously that's an ibuffer-projectile exclusive, not ibuffer-vc
                         (ibuffer-do-sort-by-alphabetic))))               ; https://emacs.stackexchange.com/questions/2181/ibuffer-how-to-automatically-create-groups-per-project
    :bind ("C-x C-b" . ibuffer)                                           ; shows some of code behind projectile filter groups
    :config
    (define-ibuffer-column size-h
      (:name "Size"
             :inline t
             :summarizer
             (lambda (column-strings)
               (let ((total 0))
                 (dolist (string column-strings)
                   (setq total
                         ;; like, ewww ...
                         (+ (float (ajv/human-readable-file-sizes-to-bytes string))
                            total)))
                 (ajv/bytes-to-human-readable-file-sizes total)))  ;; :summarizer nil
             )
      (ajv/bytes-to-human-readable-file-sizes (buffer-size)))
    (setq ibuffer-formats
          '((mark modified read-only vc-status-mini " "
                  (icon 2 2 :center :elide)
                  " "
                  (name 18 18 :left :elide)
                  " "
                  (size-h 9 -1 :right)
                  " "
                  (mode 20 20 :left :elide)
                  " "
                  (vc-status 16 16 :left)
                  " "
                  vc-relative-file))))
#+end_src

*** Which-key

| =which-key= | https://github.com/justbur/emacs-which-key |

Emacs has a lot of keybindings. I can't remember every keybinding. I
use a tool to remember every keybinding for me.

#+begin_src emacs-lisp
  (use-package which-key
    :defer 1
    :diminish
    :config (which-key-mode)
    (setq which-key-add-column-padding 3)) ; Easier to visually separate columns
#+end_src

*** Linum

| =linum= | Built-in |

#+begin_src emacs-lisp
  (use-package linum
    :hook (prog-mode . linum-mode)
    :config
    (defun linum-format-func (line)
      (let ((w (length (number-to-string (count-lines (point-min) (point-max))))))
        (propertize (format (format "%%%dd " w) line) 'face 'linum)))
    (setq linum-format 'linum-format-func))
#+end_src

*** Modeline

| =doom-modeline= | https://github.com/seagle0128/doom-modeline |
| =diminish=      | https://github.com/emacsmirror/diminish     |

Since I haven't gotten around to customizing my modeline yet, I just
use =doom-modeline=.

#+begin_src emacs-lisp
  (use-package doom-modeline ; Later, replace with custom following similar process to https://www.gonsie.com/blorg/modeline.html
    :hook (after-init . doom-modeline-mode)
    :custom                               ; Could use more use-package-ifying
    (doom-modeline-height 20)             ; To better employ its features.
    (doom-modeline-bar-width 1)
    (doom-modeline-icon t)
    (doom-modeline-major-mode-icon t)
    (doom-modeline-major-mode-color-icon t)
    (doom-modeline-buffer-file-name-style 'truncate-upto-project)
    (doom-modeline-buffer-state-icon t)
    (doom-modeline-buffer-modification-icon t)
    (doom-modeline-minor-modes nil)
    (doom-modeline-enable-word-count nil)
    (doom-modeline-buffer-encoding t)
    (doom-modeline-indent-info nil)
    (doom-modeline-checker-simple-format t)
    (doom-modeline-vcs-max-length 12)
    (doom-modeline-env-version t)
    (doom-modeline-irc-stylize 'identity)
    (doom-modeline-github-timer nil)
    (doom-modeline-gnus-timer nil))
#+end_src

To help me when I actually do customize the modeline myself, I'll have
=diminish= to hide my active minor modes.

#+begin_src emacs-lisp
  (use-package diminish)
#+end_src

*** Dashboard

| =dashboard= | https://github.com/emacs-dashboard/emacs-dashboard |

Show a dashboard on startup.

#+begin_src emacs-lisp
  (use-package dashboard
    :hook (after-init . dashboard-setup-startup-hook)
    :config
    (setq dashboard-project-backend 'projectile
          ;; initial-buffer-choice (lambda () (get-buffer "*dashboard*"))
          dashboard-set-navigator t
          dashboard-startup-banner 'logo
          dashboard-items '((projects  . 8)
                            (bookmarks . 5)
                            (recents . 5)
                            (agenda . 5))
          dashboard-set-heading-icons t
          dashboard-set-file-icons t))
#+end_src

*** Beacon

| =beacon= | https://github.com/Malabarba/beacon |

Highlight the line the cursor is on when scrolling.

#+begin_src emacs-lisp
  (use-package beacon
    :defer 1
    :config (beacon-mode 1))
#+end_src

** Navigation

*** Ivy

| =ivy=                    | https://github.com/abo-abo/swiper                    |
| =counsel=                | https://github.com/abo-abo/swiper                    |
| =swiper=                 | https://github.com/abo-abo/swiper                    |

Let's start with the backbone of it all. =Ivy= provides a
completion engine that =counsel= and =swiper= build off of. 

#+begin_src emacs-lisp
  (use-package ivy
    :diminish
    :hook (after-init . ivy-mode)
    :config
    (setq ivy-use-virtual-buffers t       ; Recent files and bookmarks in ivy-switch-buffer
          ivy-count-format "%d/%d "
          ivy-wrap t))                     ; Wrap around with next-line and previous-line
#+end_src

=counsel= provides many custom functions designed to take advantage of
=ivy=, such as =counsel-find-file=.

FIXME: I'd prefer to find a way to load =counsel= without needing to
use ~:demand t~. I tried ~ivy-mode-hook~ but that caused issues with =prescient=.

#+begin_src emacs-lisp
  (use-package counsel
    :diminish
    :demand t
    :after ivy
    ;; :bind ("C-x b" . counsel-switch-buffer) ; Disabled due to slowdowns
    :config (counsel-mode))
#+end_src

=swiper= is an =isearch= alternative, which is good because I don't
like =isearch=.

#+begin_src emacs-lisp
  (use-package swiper
    :after ivy
    :bind (("C-s" . swiper)
           ("C-r" . swiper)))
#+end_src

**** Ivy Rich

| =ivy-rich=               | https://github.com/Yevgnen/ivy-rich                  |
| =all-the-icons-ivy-rich= | https://github.com/seagle0128/all-the-icons-ivy-rich |

=ivy-rich= makes things look purdy.

#+begin_src emacs-lisp
  (use-package ivy-rich
    :after (ivy counsel)
    :config
    (ivy-rich-mode 1)
    (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line) ; Recommended in Github repo
    (setq ivy-rich-parse-remote-buffer nil ; https://github.com/Yevgnen/ivy-rich/issues/47
          ivy-rich-parse-remote-file-path nil
          ivy-rich-path-style (quote full)))
#+end_src

=all-the-icons-ivy-rich= makes the purdy thing look purdy.

#+begin_src emacs-lisp
  (use-package all-the-icons-ivy-rich
    :after all-the-icons ivy-rich
    :config (all-the-icons-ivy-rich-mode 1))
#+end_src

**** Counsel-Tramp

| =counsel-tramp= | https://github.com/masasam/emacs-counsel-tramp |

Provides a interface for using =counsel= completion with SSH. Entries
are populated from ~/.ssh/config~. Connections can also be added using
~counsel-tramp-custom-connections~.

Support for =docker= and =vagrant= is also provided if you are using
=docker-tramp= or =vagrant-tramp=.

#+begin_src emacs-lisp
  (use-package counsel-tramp
    :bind ("C-c t" . counsel-tramp))
#+end_src

*** Prescient

| =prescient=         | https://github.com/raxod502/prescient.el |
| =ivy-prescient=     | https://github.com/raxod502/prescient.el |
| =company-prescient= | https://github.com/raxod502/prescient.el |

=prescient= provide a new completion library for =ivy=, =counsel=, and
and/or =selectrum=.

#+begin_src emacs-lisp
  (use-package prescient
    :after ivy
    :config (prescient-persist-mode)      ; Save history
    )
#+end_src

=ivy-prescient= provides integration between =ivy= and =prescient=. As
=counsel= modifies user options of =ivy=, we must load it first.

#+begin_src emacs-lisp
  (use-package ivy-prescient
    :after counsel
    :config (ivy-prescient-mode)
    (setq ivy-prescient-retain-classic-highlighting t)) ; Hard to see matching regions otherwise
#+end_src

=company-prescient= provides integration between =company= and
=prescient=.

#+begin_src emacs-lisp
  (use-package company-prescient
    :after company
    :config (company-prescient-mode))
#+end_src

*** Projectile

| =projectile=         | https://github.com/bbatsov/projectile           |
| =counsel-projectile= | https://github.com/ericdanan/counsel-projectile |

#+begin_src emacs-lisp
  (use-package projectile
    :diminish
    :config (projectile-mode +1)
    (setq projectile-completion-system 'ivy) ; Dashboard support
    :bind-keymap ("C-c p" . projectile-command-map))
#+end_src

=counsel-projectile= provides integration between =projectile= and
=counsel=.

#+begin_src emacs-lisp
  (use-package counsel-projectile
    :after (counsel projectile)
    :config (counsel-projectile-mode))
#+end_src

*** Window Management

| =ace-window= | https://github.com/abo-abo/ace-window |

Running ~other-window~ a billion times isn't exactly enjoyable. What
is enjoyable is executing ~ace-window~ once and typing 1-2 keys to
select a window.

Instead of 0-9, =ace-window= will use the home row keys to select a
window.

#+begin_src emacs-lisp
  (use-package ace-window
    :defines aw-keys
    :commands ace-window
    :bind* ("M-o" . 'ace-window) ; * as ibuffer overrides M-o. Consider adjusting as M-o is used for ivy-dispatching-done
    :config (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+end_src

*** Avy

| =avy= | https://github.com/abo-abo/avy |

Easier navigation within a buffer. Run ~avy-goto-char-2~, type two
characters, then use the home row to select where to move the cursor.

#+begin_src emacs-lisp
  (use-package avy
    :bind ("C-;" . avy-goto-char-2))
#+end_src

** Editing

This section is for non-language-specific customizations that still
help with editing.

*** Parentheses

| =highlight-parentheses= | https://github.com/tsdh/highlight-parentheses.el |
| =smartparens=           | https://github.com/Fuco1/smartparens             |

Apparently =rainbow-delimiters= provides similar functionality to
=highlight-parentheses=, I'll look into it later.

#+begin_src emacs-lisp
  (use-package highlight-parentheses
    :diminish
    :hook ((prog-mode org-mode) . highlight-parentheses-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package smartparens
    :diminish
    :hook (prog-mode . smartparens-mode)
    :config (require 'smartparens-config))
#+end_src

*** wgrep

| =wrep= | https://github.com/mhayashi1120/Emacs-wgrep |

#+begin_src emacs-lisp
  (use-package wgrep
    :defer 1)
#+end_src

*** Company

| =company= | https://github.com/company-mode/company-mode |

A text-completion framework. Would like to replace RET with C-j like
=ivy=.

#+begin_src emacs-lisp
  (use-package company
    :defines company-minimum-prefix-length company-frontends company-idle-delay
    :diminish
    :hook (prog-mode . company-mode)
    :config
    (setq company-minimum-prefix-length 1)
    (setq company-frontends '(company-pseudo-tooltip-frontend
                              company-echo-metadata-frontend))
    (setq company-idle-delay 1))
#+end_src

*** Flycheck

| =flycheck= | https://github.com/flycheck/flycheck |

Syntax checking for Emacs.

#+begin_src emacs-lisp
  (use-package flycheck
    :diminish
    :defer 1
    :config (setq flycheck-emacs-lisp-load-path 'inherit)  ; Fixes "org-mode-map" in comment-dwin-2 from being undefined
    (define-key flycheck-mode-map flycheck-keymap-prefix nil)
    (setq flycheck-keymap-prefix (kbd "C-c f"))
    (define-key flycheck-mode-map flycheck-keymap-prefix
      flycheck-command-map)
    (global-flycheck-mode))                                ; Does not fix issues with functions may not be defined
#+end_src

**** DONE Replace keybinding C-c ! so it doesn't conflict with org-time-stamp-inactive
CLOSED: [2021-02-02 Tue 14:14]

*** Comments

| =comment-dwim-2= | https://github.com/remyferre/comment-dwim-2 |

I don't enjoy how ~comment-dwim~ and ~comment-line~ are two different
keys for very similar functionality. =comment-dwim-2= provides that
and a bit more. Sometimes indentation seems weird in elisp with
comments not lining up.

This is currently bugged with =enh-ruby-mode=. End of line comments
are not inserted, although it can successfully comment and uncomment
an entire line.

#+begin_src emacs-lisp
  (use-package comment-dwim-2
    :config
    (defadvice comment-indent (around comment-indent-with-spaces activate) ; Not the cause of enh-ruby-mode issue
      (let ((orig-indent-tabs-mode indent-tabs-mode))
        (when orig-indent-tabs-mode
          (setq indent-tabs-mode nil))
        ad-do-it
        (when orig-indent-tabs-mode
          (setq indent-tabs-mode t))))
    ;; Disabled for now. I want to remove line comment, keeping the
    ;; end of line comment unless I press M-; again.
    ;; Note though, text is killed, not deleted. You can always just
    ;; use C-e C-y to yank the text back at end of line
    ;; (defun cd2/inline-comment-command () ; this is the function called when you repeat the command
    ;;   ;; do nothing (not killing the end-of-line comment)
    ;;   (setq this-command nil) ; This is just a trick so that the command can still be called indefinitely
    ;;   )
    (define-key org-mode-map (kbd "M-;") 'org-comment-dwim-2)
    :bind ("M-;" . comment-dwim-2))
#+end_src

*** zzz to char

| =zzz to char= | https://github.com/mrkkrp/zzz-to-char |

Replace ~zap-to-char~ and ~zap-up-to-char~ with ~zzz~ equivalents. I
can select a  specific character, either forward or back, with the
home row. As opposed to the closest character.

#+begin_src emacs-lisp
  (use-package zzz-to-char
    :bind ("M-z" . zzz-to-char))
#+end_src

** Languages

*** Ruby

| =rbenv=    | https://github.com/senny/rbenv.el        |
| =inf-ruby= | https://github.com/nonsequitur/inf-ruby/ |
| =robe=     | https://github.com/dgutov/robe           |

=rbenv= for Emacs is 7 years old and unmainted. I'd like to replace it
sooner rather than later.

#+begin_src emacs-lisp
  (use-package rbenv
    :diminish
    :hook (ruby-mode . global-rbenv-mode))
#+end_src

=inf-ruby= is something I don't know how to use well yet. If you use
=irb= in =shell=, you will want the line =IRB.conf[:USE_MULTILINE] =
false= in =~/.config/irb/irbrc=, as otherwise you will just get
downward pointing arrows and no input or output.
Tested \approx 4/2020, didn't observe 11/2020 but may still be present.

[[https://github.com/nonsequitur/inf-ruby/issues/133][Here]] is a trick for guarding the IRB.conf clause so it won't impact
IRB sessions outside of Emacs. (Not tested thoroughly!)


#+begin_src emacs-lisp
  (use-package inf-ruby ; Latest version has --nomultline by default, but not for bundle console, only ruby
    :hook (ruby-mode . inf-ruby-minor-mode))
#+end_src

I really want to replace =robe= with =lsp-mode= and
=solargraph=. Having to run a full-blown interpreter seems overkill
and prone to errors.

#+begin_src emacs-lisp
  (use-package robe
    :defines company-backends
    :diminish
    :hook (enh-ruby-mode . robe-mode)
    :config (push 'company-robe company-backends))
#+end_src

*** YAML

| =yaml-mode= | https://github.com/yaml/yaml-mode |

Pretty much only one package for YAML.

#+begin_src emacs-lisp
  (use-package yaml-mode
    :mode "\\.yml\\'")
#+end_src

*** Assembly

#+begin_quote
AsmMode is a simple assembly programming mode that comes with Emacs.
It is based on TextMode. See AssemblyProgramming for alternatives.

AsmMode has some strange (relative to other Emacs modes) defaults for
indentation (as of Emacs 24.5): It sets ‘tab-always-indent’ to ‘nil’
so that hitting ‘TAB’ will each time insert a tab stop, pushing the
code farther to the right. Therefore I suggest using the following
config which resets ‘tab-always-indent’ back to the default:
#+end_quote

~asm-comment-char~ seems to have been deprecated, so I removed it.

[[https://www.emacswiki.org/emacs/AsmMode]]

#+begin_src emacs-lisp
  (defun my-asm-mode-hook ()
    ;; asm-mode sets it locally to nil, to "stay closer to the old TAB behaviour".
    (setq tab-always-indent (default-value 'tab-always-indent)))

  (add-hook 'asm-mode-hook #'my-asm-mode-hook)
#+end_src

** Org

| =org= | https://orgmode.org/ |

I use a more up-to-date version of Org than what Emacs ships with.
Currently ~org-adapt-identation~ does not work with ~'headline-data~.
(At least, I haven't gotten it work successfully.) Tested 11/2020.

Additionally, I want org to support as many languages as possible
without needing to add them all to ~org-babel-load-languages~.

I added a function from [[https:emacs.stackexchange.com/questions/3387][StackExchange]] to update \( \LaTeX \) symbols
as I zoom in. For time sake, the code that toggles the preview was
removed, as Emacs takes quite a while to regenerate the images. When
rapidly zooming (e.g. C-mouse-4), Emacs could even halt entirely. I do
let it remove existing previews so I don't have a mix of small and big
previews.

#+begin_src emacs-lisp
  (use-package org
    :mode (("\\.org$" . org-mode))
    :hook (org-mode . turn-on-auto-fill)  ; Don't make me spam M-q
    :bind ("C-c a" . org-agenda)
    (:map org-mode-map ("C-c j" . counsel-org-goto))
    :after (counsel)                      ; Not functionally needed, just in case for the binding
    :config
    (setq org-startup-folded t
	  org-cycle-separator-lines 1
	  org-log-done 'time
	  org-adapt-indentation nil
	  org-fontify-whole-block-delimiter-line nil
	  org-hide-emphasis-markers t
	  org-confirm-babel-evaluate nil
	  org-agenda-files '("~/org")
	  org-format-latex-options (plist-put org-format-latex-options :scale 1.5)
	  org-blank-before-new-entry '((heading . t) (plain-list-item . t)))
    (font-lock-add-keywords 'org-mode
			    '(("^ *\\([-]\\) "
			       (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
    ;; Decrease heading size based on level
    (let ((i 1.6))                
      (dolist (face '(org-level-1
		      org-level-2
		      org-level-3
		      org-level-4
		      org-level-5
		      org-level-6
		      org-level-7
		      org-level-8))
	(set-face-attribute face nil :weight 'semi-bold :height i)
	(setq i (- i 0.05))))
    ;; Automatically add used languages to org-babel
    (defadvice org-babel-execute-src-block (around load-language nil activate)
      "Load language if needed"
      (let ((language (org-element-property :language (org-element-at-point))))
	(unless (cdr (assoc (intern language) org-babel-load-languages))
	  (add-to-list 'org-babel-load-languages (cons (intern language) t))
	  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
	ad-do-it))
    (defun update-org-latex-fragment-scale ()
      (org-latex-preview '(64))
      (let ((text-scale-factor (expt text-scale-mode-step text-scale-mode-amount)))
	(plist-put org-format-latex-options :scale (* 2.3 text-scale-factor)))
      )
    (add-hook 'text-scale-mode-hook 'update-org-latex-fragment-scale))
#+end_src

*** Extensions

| =org-superstar= | https://github.com/integral-dw/org-superstar-mode |
| =ob-mermaid=    | https://github.com/arnm/ob-mermaid                |
| =gnuplot=       | https://github.com/emacsorphanage/gnuplot         |

I enjoy colored bullets. I might remove
~org-superstar-leading-bullets~ since it doesn't bother me too much
and doesn't seem to work anyway.

#+begin_src emacs-lisp
  (use-package org-superstar
    :hook (org-mode . org-superstar-mode)
    :config
    (org-superstar-configure-like-org-bullets) ; FIXME stars are still visible despite below line
    (setq org-superstar-leading-bullet ?\s))
#+end_src

A picture is worth a thousand words, even in Org. I should try to make
it more compatible with other installations.

#+begin_src emacs-lisp
  (use-package ob-mermaid
    :after org
    :config
    (setq ob-mermaid-cli-path "~/.node_modules/.bin/mmdc"))
#+end_src

While not quite a picture, graphs are also nice to have. This allows
for gnuplot src blocks in org mode. The =gnuplot= emacs package might also be
required, although I think it comes built in with recent versions of
=org=.

#+begin_src emacs-lisp
    (use-package gnuplot)
#+end_src

**** mixed-pitch

| =mixed-pitch= | https://gitlab.com/jabranham/mixed-pitch |

#+begin_quote
Mixed pitch is a minor mode that enables mixing fixed-pitch (also known as
fixed-width or monospace) and variable-pitch (AKA “proportional”) fonts. It
tries to be smart about which fonts get which face. Fonts that look like code,
org-tables, and such remain fixed-pitch and everything else becomes
variable-pitch. The variable ~mixed-pitch-fixed-pitch-faces~ is a list of faces
that will remain fixed-pitch in ~mixed-pitch-mode~.
#+end_quote

#+begin_src emacs-lisp
  (use-package mixed-pitch
    :hook (org-mode . mixed-pitch-mode))
#+end_src

** Utilities

This is meant for utility packages that don't assist with editing,
navigation, or similar, but still provide a benefit.

*** 0xc

| =0xc= |  https://github.com/AdamNiederer/0xc |

A package that provides easy base conversions inside of Emacs.

#+begin_src emacs-lisp
  (use-package 0xc
    :commands (0xc-convert 0xc-convert-point 0xc-live-convert))
#+end_src

*** Esup

| =Esup= | https://github.com/jschaf/esup |

Profile Emacs startup times with =M-x esup=. There's an apparent issue
with some combination of =straight=, =esup= and byte-compiling that
causes =Esup= to fail to run, either showing =Symbolic link to Git...=
or another error message. [[https://github.com/jschaf/esup/issues/54#issuecomment-651247749][This]] contains a fix.

It seems the fix isn't perfect, Esup is largely underestimating my
startup time. When I look in the breakdown, large sections of the code
are unaccounted for.

#+begin_src emacs-lisp
  (use-package esup
    :commands esup
    :config (setq esup-depth 0))
#+end_src

*** PDF Tools

| =PDF Tools= | https://github.com/politza/pdf-tools |

#+begin_quote
PDF Tools is, among other things, a replacement of DocView for PDF
files. The key difference is that pages are not pre-rendered by e.g.
ghostscript and stored in the file-system, but rather created
on-demand and stored in memory.

[…]

Actually, displaying PDF files is
just one part of PDF Tools. Since poppler can provide us with all
kinds of information about a document and is also able to modify it,
there is a lot more we can do with it.
#+end_quote

This package requires a Unix-based OS.

#+begin_src emacs-lisp
(unless sys/win32p
  (use-package pdf-tools
    :mode ("\\.pdf\\'" . pdf-tools-install)))
#+end_src

*** Restart Emacs

| =restart-emacs= | https://github.com/iqbalansari/restart-emacs |

A small package to restart Emacs within Emacs.

#+begin_src emacs-lisp
      (use-package restart-emacs
        :commands restart-emacs
        :config (setq restart-emacs-restore-frames t))
#+end_src

*** Unbound

| =unbound= | https://www.emacswiki.org/emacs/unbound.el |

Find unbound keys with ~describe-unbound-keys~ and enter a number
representing complexity.

FIXME: Fixed most errors except an ~Unused lexical variable 'i'~ in
~defun key-complexity~. The variable is definitely used; I'm not sure
what the issue is.

#+begin_src emacs-lisp :tangle no
    ;;; unbound.el --- Find convenient unbound keystrokes

  ;; Copyright (C) 2007 Davis Herring

  ;; Author: Davis Herring <herring@lanl.gov>
  ;; Version: 0.1
  ;; Maintainer: Davis Herring
  ;; Keywords: keyboard

  ;; This file is not part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation; either version 2, or (at your option)
  ;; any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program; see the file COPYING.  If not, write to the
  ;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor
  ;; Boston, MA 02110-1301, USA.

    ;;; Commentary:
  ;; The only entry point is `describe-unbound-keys'; it prompts for the maximum
  ;; complexity to allow, which should probably be at least 5 to find enough
  ;; keys to be worthwhile.  Lisp may call just `unbound-keys' to get a list of
  ;; key representations suitable for `define-key'.

    ;;; Code:

  (eval-when-compile (require 'cl))       ; for `dotimes', `push' (Emacs 21)

  (defgroup unbound nil                   ; Silence group not specified warnings from compiler
    "Show unbound keys based on complexity."
    :group 'convenience)

  (defcustom unbound-modifiers '(control meta shift)
    "Modifiers to consider when searching for unbound keys."
    :type '(set (const control) (const meta) (const shift)
                (const super) (const hyper) (const alt)))

  (defvar unbound-key-list
    (let (keys)
      (dotimes (i (- ?\d ?\  -1))
        (push (+ i ?\ ) keys))
      (dotimes (i 12)
        (push (intern (format "f%s" (1+ i))) keys))
      (append '(?\t ?\r ?\e) (nreverse keys)
              '(insert delete home end prior next up down left right)))
    "Keys to consider when searching for unbound keys.")

  (defun key-complexity (key)
    "Return a complexity score for key sequence KEY.
    Currently KEY must be of the [(control shift ?s) ...] format."
    (let ((ret 0))
      (dotimes (i (length key) ret)
        (setq ret (+ ret (* i 2) (key-complexity-1 (aref key i)))))))

  ;; This is somewhat biased for US keyboards.
  (defun key-complexity-1 (key)           ; key:=(modifiers... key)
    (+ (if (memq 'control key) 1 0)
       (if (memq 'meta key) 2 0)
       (if (memq 'shift key) 3 0)
       (if (memq 'super key) 4 0)
       (if (memq 'hyper key) 4 0)
       (if (memq 'alt key) 3 0)
       (* 2 (1- (length key)))
       (progn
         (setq key (car (last key)))
         (if (integerp key)
             (cond ((and (>= key ?a) (<= key ?z)) 0)
                   ((and (>= key ?A) (<= key ?Z)) 6) ; capitals are weird
                   ((and (>= key ?0) (<= key ?9)) 2)
                   ((memq key '(?\b ?\r ?\ )) 1)
                   ;; Unshifted punctuation (US keyboards)
                   ((memq key '(?` ?- ?= ?\t ?\[ ?\] ?\\ ?\; ?' ?, ?. ?/)) 3)
                   ;; Other letters -- presume that one's keyboard has them if
                   ;; we're going to consider binding them.
                   ((let (case-fold-search)
                      (string-match
                       "[016A]" (category-set-mnemonics
                                 (char-category-set key)))) 2)
                   (t 5))
           7))))

  ;; Quiet the byte compiler
  (defvar unbound-keys nil
    "Used internally by `unbound-keys'.")

  (defun unbound-keys (max &optional map)
    "Return a list of unbound keystrokes of complexity no greater than MAX.
    Keys are sorted by their complexity; `key-complexity' determines it."
    (let (unbound-keys)
      (unbound-keys-1 max map nil)
      (mapcar 'car (sort unbound-keys (lambda (k l) (< (cdr k) (cdr l)))))))

  ;; Adds to `unbound-keys'.
  (defun unbound-keys-1 (max map pfx)
    (dolist (base unbound-key-list)
      (dotimes (modi (lsh 1 (length unbound-modifiers)))
        (let ((key (list base)))
          (dotimes (j (length unbound-modifiers))
            (unless (zerop (logand modi (lsh 1 j)))
              (push (nth j unbound-modifiers) key)))
          (let ((total (vconcat pfx (list key))) comp)
            ;; Don't use things that get translated and bound.  This isn't
            ;; perfect: it assumes that the entire key sequence is translated.
            (unless (or (let ((trans (lookup-key function-key-map total)))
                          (and (vectorp trans) (key-binding trans)))
                        ;; Don't add `shift' to any graphic character; can't
                        ;; type it, or it's redundant.
                        (and (memq 'shift key) (integerp base)
                             (> base ?\ ) (<= base ?~))
                        ;; Don't add `control' when it generates another
                        ;; character we use:
                        (and (memq 'control key) (integerp base)
                             (< base ?`)
                             (memq (- base 64) unbound-key-list))
                        ;; Limit the total complexity:
                        (> (setq comp (key-complexity total)) max))
              (let ((res (if map (lookup-key map (vector key))
                           (key-binding (vector (if (cdr key) key (car key)))))))
                (cond ((keymapp res)
                       ;; Don't add anything after an ESC, to avoid Meta
                       ;; confusion.
                       (unless (eq base ?\e)
                         (unbound-keys-1 max res total)))
                      (res)
                      (t (push (cons total comp) unbound-keys))))))))))

    ;;;###autoload
  (defun describe-unbound-keys (max &optional map)
    "Display a list of unbound keystrokes of complexity no greater than MAX.
    Keys are sorted by their complexity; `key-complexity' determines it."
    (interactive
     (list (read-number "Maximum key complexity: ")
           (intern (read-string "Keymap (default global-map): " nil nil "global-map"))))
    (unless (keymapp (eval map)) (error "%s is not a keymap" map))
    (with-output-to-temp-buffer "*Unbound Keys*"
      (let ((keys (unbound-keys max (eval map))))
        (princ (format "%s unbound keys in %s with complexity at most %s:\n"
                       (length keys) map max))
        (princ (mapconcat 'key-description keys "\n")))))

  (provide 'unbound)

  ;; Local variables:
  ;; indent-tabs-mode: nil
  ;; End:

    ;;; unbound.el ends here
#+end_src

*** vterm

| =vterm= | https://github.com/akermu/emacs-libvterm |

A capable terminal emulator. This is compatible with =irb= multiline.
Projectile also supports creating a named vterm with
~projectile-run-vterm~.

#+begin_src emacs-lisp
  (use-package vterm
    :commands vterm)
#+end_src

**** vterm-toggle

| =vterm-toggle= | https://github.com/jixiuf/vterm-toggle |

#+begin_quote
This package provides the command vterm-toggle which toggles between
the vterm buffer and whatever buffer you are editing.
#+end_quote

#+begin_src emacs-lisp
  (use-package vterm-toggle
    :commands vterm-toggle vterm-toggle-cd
    :bind ("C-c v" . vterm-toggle))
#+end_src

*** Magit

| =magit= | [[https:magit.vc]] |

I'm certainly not at a point where I fully grasp the intricacies of
=magit= (=git= alone is enough of a pain!), but I can't possibly get
better without practice!

#+begin_src emacs-lisp
  (use-package magit)
#+end_src

** Games

*** Zone

A neat little screensaver for buffers.

#+begin_src emacs-lisp
  (use-package zone
    :commands (zone-when-idle zone-choose)
    :defer 5
    :config
    (zone-when-idle 600)
    (defun zone-choose (pgm)
      "Choose a PGM to run for `zone'."
      (interactive
       (list
        (completing-read
         "Program: "
         (mapcar 'symbol-name zone-programs))))
      (let ((zone-programs (list (intern pgm))))
        (zone))))
#+end_src

* List of TODOs

** TODO Move to solargrph and lsp-mode
** TODO move functions to :preface in =use-package=
** TODO Make an actual TODO list.
** DONE Alphabetize sensible defaults
CLOSED: [2020-11-10 Tue 14:49]
** DONE Some sort of solution to prevent needing to initialize straight in init
CLOSED: [2020-11-09 Mon 11:02]
Don't want to do that.
https://jonathanabennett.github.io/blog/2019/05/28/emacs.org-~-may-2019/
might have a solution with tangling.
** DONE Do we need straight in init.el?
CLOSED: [2020-11-09 Mon 11:02]
Any drawbacks from loading with old org version then upgrading?
** TODO Can we move speedup into =early-init.el=?
[[https://old.reddit.com/r/emacs/comments/dppmqj/do_i_even_need_to_leverage_earlyinitel_if_i_have/][This]] talks about how disabling certain decorations in early init is
faster. I'm curious how I can get org-tangle to export some code
blocks in one file and other code blocks in another file.

If I do this, I should set package-enable-at-startup to nil as well.

And loading org in early init wouldn't be a bad idea either.
** TODO Compatibility with tty
It had previous failed to load in a tty, complaining about listp nil.
I'm not reproducing the error now, just keep an eye out?
** TODO Better loading on gnuplot and fix two attempts to execute src blocks.
I would like to have it delay until either opening a gnuplot file or when
executing gnuplot source blocks. Additionally it fails to execute src
blocks on the first attempt when launching emacs, requiring two
attempts.

Failing to execute gnuplot on the first attempt doesn't seem to just
be limited to gnuplot, but C as well. Probably an issue with my babel advice.
** TODO Restore autosave transform
Currently files fail to save and a warning periodically appears with
it enabled.
** TODO ltximg folder no littering

** TODO Add float package to ~org-latex-packages-alist~

