#+TITLE: DotEmacs
#+AUTHOR: Richard Sent
#+PROPERTY: header-args :results silent :tangle yes

This is my personal Emacs configuration, now with 100% more =Org=!

* Installation

I'll write this up later.

* Configuration

** Meta

Much of this section was +stolen+ borrowed from [[https://github.com/larstvei/dot-emacs][larstvei]].

All changes to the configuration should be done in =init.org=, *not* in
=init.el=. Any changes in the =init.el= will be overwritten by saving
=init.org=. The =init.el= in this repo should not be tracked by git, and
is replaced the first time Emacs is started (assuming it has been renamed
to =~/.emacs.d=).

Emacs can't load =.org=-files directly, but =org-mode= provides functions
to extract the code blocks and write them to a file. There are multiple
ways of handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]], one
could just use =org-babel-load-file=, but I had problems with
byte-compilation. Previously I tracked both the =org.=- and =el.=-files,
but the git commits got a little messy. So here is a new approach.

When this configuration is loaded for the first time, the =init.el= is
the file that is loaded. It looks like this:

#+BEGIN_SRC emacs-lisp :tangle no
  ;; This file replaces itself with the actual configuration at first run.

  ;; We can't tangle without org!
  (require 'org)
  ;; Open the configuration
  (find-file (concat user-emacs-directory "init.org"))
  ;; tangle it
  (org-babel-tangle)
  ;; load it
  (load-file (concat user-emacs-directory "init.el"))
  ;; finally byte-compile it
  (byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

It tangles the org-file, so that this file is overwritten with the actual
configuration.

There is no reason to track the =init.el= that is generated; by running
the following command =git= will not bother tracking it:

#+BEGIN_SRC sh :tangle no
  git update-index --assume-unchanged init.el
#+END_SRC

If one wishes to make changes to the repo-version of =init.el= start
tracking again with:

#+BEGIN_SRC sh :tangle no
  git update-index --no-assume-unchanged init.el
#+END_SRC

I want lexical scoping for the init-file, which can be specified in the
header. The first line of the configuration is as follows:

#+BEGIN_SRC emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+END_SRC

The =init.el= should (after the first run) mirror the source blocks in
the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which
extracts the code blocks from the current file into a source-specific
file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to
the =after-save-hook= ensuring to always tangle and byte-compile the
=org=-document after changes.

#+BEGIN_SRC emacs-lisp
  (defun my/tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are
  tangled, and the tangled file is compiled."
    (when (equal (buffer-file-name)
		 (expand-file-name (concat user-emacs-directory "init.org")))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
	(org-babel-tangle)
	(byte-compile-file (concat user-emacs-directory "init.el")))))

  (add-hook 'after-save-hook 'my/tangle-init)
#+END_SRC


** Basics

*** Speedup

We want to keep the garbage collector from running while we initialize
everything. We can reset it later to a more reasonable value. If we
didn't do this, Emacs would hang when running the garbage collector.

#+begin_src emacs-lisp
  (setq-default
   gc-cons-threshold most-positive-fixnum ; 8 MiB
   gc-cons-percentage 0.6)
#+end_src

Replace the file-name-handler-alist to nil, as regexing is cpu
intensive. We need to keep the original value to restore it later. I
don't know all the details behind it, but it sounds helpful!

#+begin_src emacs-lisp
  (defvar default-file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)
#+end_src

And now we revert the changes with a startup hook. 16777216 is the
value Doom uses.

#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold 16777216
                    gc-cons-percentage 0.1
                    file-name-handler-alist default-file-name-handler-alist)))
#+end_src

Garbage-collect on focus-out. Emacs /should/ feel snappier overall.
With Emacs 27.1, focus-out-hook is deprecated.

#+BEGIN_SRC emacs-lisp
  (add-function :after after-focus-change-function (unless (frame-focus-state) #'garbage-collect))
#+END_SRC

Apparently this can result in a significant speedup when using fonts
larger or smaller than the system default.

#+begin_src emacs-lisp
  (setq frame-inhibit-implied-resize t)
#+end_src

*** Sensible Defaults

Don't randomly litter my filesystem with backups and autosaves.

#+begin_src emacs-lisp
  (setq
   backup-by-copying t                                  ; don't clobber symlinks
   backup-directory-alist                               ;
   `(("." . ,(concat user-emacs-directory "backups")))  ; don't litter my fs tree
   delete-old-versions t                                ;
   kept-new-versions 6                                  ;
   kept-old-versions 2                                  ;
   version-control t)                                   ; use versioned backups
#+end_src

I don't need no fancy user interface! These ones are only active when
in a window. Apparently putting this in early-init.el will speed up
startup even more.

#+begin_src emacs-lisp
  (push '(menu-bar-lines . 1) default-frame-alist)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)
#+end_src

And now for a bunch of one liner configurations.

#+begin_src emacs-lisp
  (setq-default
   frame-resize-pixelwise t                      ; Removes empty space at bottom of screen when maximized
   help-window-select t                          ; Select help windows when they appear
   inhibit-startup-screen t                      ; Emacs really could use a more "welcoming" welcome screen
   initial-scratch-message ""                    ; Clear scratch buffer
   next-screen-context-lines 6                   ; Keep 6 lines of context when using scroll-up/down-command
   ring-bell-bunction 'ignore                    ; My ears!
   scroll-conservatively most-positive-fixnum    ; Always scroll by one line
   scroll-preserve-screen-position t             ; Try to keep point in the same location visually
   sentence-end-double-space nil                 ; Use a single space after dots
   show-help-function nil                        ; Disable help text on most UI elements
   uniquify-buffer-name-style 'forward           ; Make buffer names unique
   )
  (defalias 'yes-or-no-p 'y-or-n-p)              ; y is shorter than yes
  (delete-selection-mode 1)                      ; If I selected something, I probably want to edit it.
  (global-auto-revert-mode 1)                    ; If I edit something elsewhere, I probably want to reload
  (global-display-line-numbers-mode)             ; Show line numbers in all buffers
  (global-hl-line-mode)                          ; Highlight the active line
  (menu-bar-mode 0)                              ; Disable the menu bar
  (put 'downcase-region 'disabled nil)           ; Is it really that confusing?
  (put 'upcase-region 'disabled nil)             ; I reiterate. Is it really that confusing?
  (set-default-coding-systems 'utf-8)            ; Default to utf-8 encoding
#+end_src

Start Emacs in fullscreen.

#+BEGIN_SRC emacs-lisp
  (if (eq window-system 'ns)
      (set-frame-parameter nil 'fullscreen 'maximized)
    (set-frame-parameter nil 'fullscreen 'fullboth))
#+END_SRC

I already know about Emacs, thank you.

#+begin_src emacs-lisp
  (fset 'display-startup-echo-area-message 'ignore)
#+end_src

*** Support =custom.el=

I have no desire for appending autogenerated elisp to =init.el=. I'd
much rather concentrate that into a single file that I call
=custom.el=. If one doesn't already exist, I want to create a blank
one.

#+BEGIN_SRC emacs-lisp
  (write-region "" "" (expand-file-name "custom.el" (file-name-directory (or load-file-name buffer-file-name))) t)
  (setq-default custom-file (expand-file-name "custom.el" (file-name-directory (or load-file-name buffer-file-name))))
  (load custom-file)
#+END_SRC

*** Constants

A slowly growing list of constants. [[https://github.com/seagle0128/.emacs.d][Centaur Emacs]] has a comprehensive
list that I haven't +stolen+ proactively borrowed yet.

#+begin_src emacs-lisp
  (defconst sys/win32p                    ; I hope I don't need this constant
    (eq system-type 'windows-nt)
    "Are we running on a WinTel system?")

  (defconst sys/linuxp
    (eq system-type 'gnu/linux)
    "Are we running on a GNU/Linux system?")

  (defconst sys/macp
    (eq system-type 'darwin)
    "Are we running on a Mac system?")

  (defconst sys/mac-x-p
    (and (display-graphic-p) sys/macp)
    "Are we running under X on a Mac system?")

  (defconst sys/mac-ns-p
    (eq window-system 'ns)
    "Are we running on a GNUstep or Macintosh Cocoa display?")

  (defconst sys/mac-cocoa-p
    (featurep 'cocoa)
    "Are we running with Cocoa on a Mac system?")

  (defconst sys/mac-port-p
    (eq window-system 'mac)
    "Are we running a macport build on a Mac system?")

  (defconst sys/linux-x-p
    (and (display-graphic-p) sys/linuxp)
    "Are we running under X on a GNU/Linux system?")

  (defconst sys/cygwinp
    (eq system-type 'cygwin)
    "Are we running on a Cygwin system?")

  (defconst sys/rootp
    (string-equal "root" (getenv "USER"))
    "Are you using ROOT user?")

  (defconst emacs/>=25p
    (>= emacs-major-version 25)
    "Emacs is 25 or above.")

  (defconst emacs/>=26p
    (>= emacs-major-version 26)
    "Emacs is 26 or above.")

  (defconst emacs/>=27p
    (>= emacs-major-version 27)
    "Emacs is 27 or above.")

  (defconst emacs/>=25.3p
    (or emacs/>=26p
	(and (= emacs-major-version 25) (>= emacs-minor-version 3)))
    "Emacs is 25.3 or above.")

  (defconst emacs/>=25.2p
    (or emacs/>=26p
	(and (= emacs-major-version 25) (>= emacs-minor-version 2)))
    "Emacs is 25.2 or above.")
#+end_src

*** Straight Bootstrap

I use [[https://github.com/raxod502/straight.el][straight.el]] for package management. This is boostrap code from
the Github repo to set up straight.

I wrapped it in an =eval-and-compile= because =flycheck= thought every
variable I configured in =use-package= didn't exist. Credit to
[[https://reddit.com/r/emacs/comments/gwupwt/noob_please_help_to_resolve_the_flycheck_error/ft1kk2j/][/u/cpitclaudel]] on Reddit for the solution! It's not perfect; functions
are still recognized as undefined, but at least that is condensed into
one warning at the end.

Now that I'm byte compiling my init file as a whole, this wrapper
might not be needed.

#+begin_src emacs-lisp
  (defvar straight-fix-flycheck t)
  (defvar bootstrap-version)
  (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
  (straight-use-package 'use-package)       ; Install use-package
  (setq straight-use-package-by-default t)    ; I don't want to type :straight t a billion times
#+end_src

*** Bind-keys Bootstrap

I'm not entirely sure why this is necessary, and more importantly,
what better solutions there are. But when byte-compiling Emacs,
bind-keys isn't properly loaded by use-package. This means any
custom (and most built-in) keybindings are nonfunctional.

Solution found [[https://old.reddit.com/r/emacs/comments/c6fvvr/unable_to_initialize_package_with_usepackage/es92xjd/][here]].

#+begin_src emacs-lisp
  (use-package bind-key
    :config
    (add-to-list 'same-window-buffer-names "*Personal Keybindings*"))
#+end_src


** Functions
Custom functions from various sources that I use later on in the init
file.

Return t if a font is installed, nil otherwise.
#+begin_src emacs-lisp
  (defun aorst/font-installed-p (font-name)
    "Check if font with FONT-NAME is available."
    (if (find-font (font-spec :name font-name))
        t
      nil))
#+end_src

A duo of functions for getting human readable file sizes.
#+begin_src emacs-lisp
  (defun ajv/human-readable-file-sizes-to-bytes (string)
    "Convert a human-readable file size into bytes."
    (interactive)
    (cond
     ((string-suffix-p "G" string t)
      (* 1000000000 (string-to-number (substring string 0 (- (length string) 1)))))
     ((string-suffix-p "M" string t)
      (* 1000000 (string-to-number (substring string 0 (- (length string) 1)))))
     ((string-suffix-p "K" string t)
      (* 1000 (string-to-number (substring string 0 (- (length string) 1)))))
     (t
      (string-to-number (substring string 0 (- (length string) 1))))
     )
    )
  (defun ajv/bytes-to-human-readable-file-sizes (bytes)
    "Convert number of bytes to human-readable file size."
    (interactive)
    (cond
     ((> bytes 1000000000) (format "%10.1fG" (/ bytes 1000000000.0)))
     ((> bytes 100000000) (format "%10.0fM" (/ bytes 1000000.0)))
     ((> bytes 1000000) (format "%10.1fM" (/ bytes 1000000.0)))
     ((> bytes 100000) (format "%10.0fk" (/ bytes 1000.0)))
     ((> bytes 1000) (format "%10.1fk" (/ bytes 1000.0)))
     (t (format "%10d" bytes)))
    )
#+end_src


** UI

*** Icons

| =all-the-icons=       | https://github.com/domtronn/all-the-icons.el  |
| =all-the-icons-dired= | https://github.com/jtbm37/all-the-icons-dired |

I like having pretty icons next to a lot of things. I also don't like
remembering to install them on a new machine.


#+begin_src emacs-lisp
  (use-package all-the-icons
    :config
    (when (and (not (aorst/font-installed-p "all-the-icons"))
               (window-system))
      (all-the-icons-install-fonts t))
    :defer 1)
#+end_src

I also like having them in dired.

#+begin_src emacs-lisp
  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

*** Themes

| =doom-themes= | https://github.com/hlissner/emacs-doom-themes |

Why install one theme when many will do? Yeah, that sounds right.

#+begin_src emacs-lisp
  (use-package doom-themes
    :config (load-theme 'doom-nord t))
#+end_src

*** Font

I like being able to see the text on my screen.

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(font . "Fira Code-12"))
#+end_src

*** Ibuffer

| =all-the-icons-ibuffer= | https://github.com/seagle0128/all-the-icons-ibuffer |
| =ibuffer-vc=            | https://github.com/purcell/ibuffer-vc               |

First and foremost, replace =list-buffers= with =Ibuffer=

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

Next, I'll set up some pretty icons.

#+begin_src emacs-lisp
  (use-package all-the-icons-ibuffer
    :diminish
    :after all-the-icons)
#+end_src

Time to actually make =Ibuffer= functional by setting up automatic version
control groups.

#+begin_src emacs-lisp
  (use-package ibuffer-vc ; Also consider ibuffer-projectile
    :after all-the-icons-ibuffer
    :hook (ibuffer . (lambda () (ibuffer-vc-set-filter-groups-by-vc-root) ; Look at combining with custom ibuffer groups with 'ibffuer-projectile-generate-filter-groups
                       (unless (eq ibuffer-sorting-mode 'alphabetic)      ; Obviously that's an ibuffer-projectile exclusive, not ibuffer-vc
                         (ibuffer-do-sort-by-alphabetic))))               ; https://emacs.stackexchange.com/questions/2181/ibuffer-how-to-automatically-create-groups-per-project
    :bind ("C-x C-b" . ibuffer)                                           ; shows some of code behind projectile filter groups
    :config
    (define-ibuffer-column size-h
      (:name "Size"
             :inline t
             :summarizer
             (lambda (column-strings)
               (let ((total 0))
                 (dolist (string column-strings)
                   (setq total
                         ;; like, ewww ...
                         (+ (float (ajv/human-readable-file-sizes-to-bytes string))
                            total)))
                 (ajv/bytes-to-human-readable-file-sizes total)))  ;; :summarizer nil
             )
      (ajv/bytes-to-human-readable-file-sizes (buffer-size)))
    (setq ibuffer-formats
          '((mark modified read-only vc-status-mini " "
                  (icon 2 2 :center :elide)
                  " "
                  (name 18 18 :left :elide)
                  " "
                  (size-h 9 -1 :right)
                  " "
                  (mode 20 20 :left :elide)
                  " "
                  (vc-status 16 16 :left)
                  " "
                  vc-relative-file))))
#+end_src

*** Which-key

| =which-key= | https://github.com/justbur/emacs-which-key |

Emacs has a lot of keybindings. I can't remember every keybinding. I
use a tool to remember every keybinding for me.

#+begin_src emacs-lisp
  (use-package which-key
    :defer 1
    :diminish
    :config (which-key-mode)
    (setq which-key-add-column-padding 3)) ; Easier to visually seperate columns
#+end_src

*** Modeline

| =doom-modeline= | https://github.com/seagle0128/doom-modeline |
| =diminish=      | https://github.com/emacsmirror/diminish     |

Since I haven't gotten around to customizing my modeline yet, I just
use =doom-modeline=.

#+begin_src emacs-lisp
  (use-package doom-modeline ; Later, replace with custom following similar process to https://www.gonsie.com/blorg/modeline.html
    :hook (after-init . doom-modeline-mode)
    :custom                               ; Could use more use-package-ifying
    (doom-modeline-height 20)             ; To better employ its features.
    (doom-modeline-bar-width 1)
    (doom-modeline-icon t)
    (doom-modeline-major-mode-icon t)
    (doom-modeline-major-mode-color-icon t)
    (doom-modeline-buffer-file-name-style 'truncate-upto-project)
    (doom-modeline-buffer-state-icon t)
    (doom-modeline-buffer-modification-icon t)
    (doom-modeline-minor-modes nil)
    (doom-modeline-enable-word-count nil)
    (doom-modeline-buffer-encoding t)
    (doom-modeline-indent-info nil)
    (doom-modeline-checker-simple-format t)
    (doom-modeline-vcs-max-length 12)
    (doom-modeline-env-version t)
    (doom-modeline-irc-stylize 'identity)
    (doom-modeline-github-timer nil)
    (doom-modeline-gnus-timer nil))
#+end_src

To help me when I actually do customize the modeline myself, I'll have
=diminish= to hide my active minor modes.

#+begin_src emacs-lisp
  (use-package diminish)
#+end_src


** Navigation

*** Ivy

| =ivy=                    | https://github.com/abo-abo/swiper                    |
| =counsel=                | https://github.com/abo-abo/swiper                    |
| =swiper=                 | https://github.com/abo-abo/swiper                    |
| =ivy-rich=               | https://github.com/Yevgnen/ivy-rich                  |
| =all-the-icons-ivy-rich= | https://github.com/seagle0128/all-the-icons-ivy-rich |

Let's start with the backbone of it all. =Ivy= provides a
completion engine that =counsel= and =swiper= build off of. 

#+begin_src emacs-lisp
  (use-package ivy
    :diminish
    :hook (after-init . ivy-mode)
    :config
    (setq ivy-use-virtual-buffers t       ; Recent files and bookmarks in ivy-switch-buffer
	  ivy-count-format "%d/%d ")
    (setq ivy-wrap t)                     ; Wrap around with next-line and previous-line
    (ivy-mode 1))
#+end_src

=counsel= provides many custom functions designed to take advantage of
=ivy=, such as =counsel-find-file=.

#+begin_src emacs-lisp
  (use-package counsel
    :diminish
    :after ivy
    :config (counsel-mode))
#+end_src

=swiper= is an =isearch= alternative, which is good because I don't
like =isearch=.

#+begin_src emacs-lisp
  (use-package swiper
    :after ivy
    :bind (("C-s" . swiper)
           ("C-r" . swiper)))
#+end_src

=ivy-rich= makes things look purdy.

#+begin_src emacs-lisp
  (use-package ivy-rich
    :functions ivy-rich-mode
    :after ivy counsel
    :config (ivy-rich-mode 1)
    (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)) ; Recommended in Github repo
#+end_src

=all-the-icons-ivy-rich= makes the purdy thing look purdy.

#+begin_src emacs-lisp
  (use-package all-the-icons-ivy-rich
    :after all-the-icons ivy-rich
    :functions all-the-icons-ivy-rich-mode
    :config (all-the-icons-ivy-rich-mode 1))
#+end_src

*** Projectile

| =projectile=         | https://github.com/bbatsov/projectile           |
| =counsel-projectile= | https://github.com/ericdanan/counsel-projectile |

#+begin_src emacs-lisp
  (use-package projectile
    :functions projectile-mode
    :diminish
    :config (projectile-mode +1)
    :bind-keymap ("C-c p" . projectile-command-map))
#+end_src

=counsel-projectile= provides integration between =projectile= and =counsel=.

#+begin_src emacs-lisp
  (use-package counsel-projectile
    :after (counsel projectile)
    :functions counsel-projectile-mode
    :config (counsel-projectile-mode))
#+end_src

*** Window Management

| =ace-window= | https://github.com/abo-abo/ace-window |

Running =other-window= a billion times isn't exactly enjoyable. What
is enjoyable is executing =ace-window= once and typing 1-2 keys to
select a window.

Instead of 0-9, =ace-window= will use the home row keys to select a
window.

#+begin_src emacs-lisp
  (use-package ace-window
    :defines aw-keys
    :functions ace-window
    :bind* ("M-o" . 'ace-window) ; * as ibuffer overrides M-o. Consider adjusting as M-o is used for ivy-dispatching done
    :config (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+end_src


** Editing

This section is for non-language-specific customizations that still
help with editing.

*** Parentheses

| =highlight-parentheses= | https://github.com/tsdh/highlight-parentheses.el |
| =smartparens=           | https://github.com/Fuco1/smartparens             |

Apparently =rainbow-delimiters= provides similar functionality to
=highlight-parentheses=, I'll look into it later.

#+begin_src emacs-lisp
  (use-package highlight-parentheses
    :diminish
    :hook (prog-mode . highlight-parentheses-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package smartparens
    :diminish
    :hook (prog-mode . smartparens-mode)
    :config (require 'smartparens-config))
#+end_src

*** wgrep

| =wrep= | https://github.com/mhayashi1120/Emacs-wgrep |

#+begin_src emacs-lisp
  (use-package wgrep
    :defer 1)
#+end_src

*** Company

| =company= | https://github.com/company-mode/company-mode |

A text-completion framework. Would like to replace RET with C-j like
=ivy=.

#+begin_src emacs-lisp
  (use-package company
    :defines company-minimum-prefix-length company-frontends company-idle-delay
    :diminish
    :hook (prog-mode . company-mode)
    :config
    (setq company-minimum-prefix-length 1)
    (setq company-frontends '(company-pseudo-tooltip-frontend
                              company-echo-metadata-frontend))
    (setq company-idle-delay 1))
#+end_src

*** Flycheck

| =flycheck= | https://github.com/flycheck/flycheck |

Syntax checking for Emacs.

#+begin_src emacs-lisp
  (use-package flycheck
    :functions global-flycheck-mode
    :diminish
    :defer 1
    :config (setq flycheck-emacs-lisp-load-path 'inherit)  ; Fixes "org-mode-map" in comment-dwin-2 from being undefined
    (global-flycheck-mode))                                ; Does not fix issues with functions may not be defined
#+end_src

*** Comments

| =comment-dwim-2= | https://github.com/remyferre/comment-dwim-2 |

I don't enjoy how =comment-dwim= and =comment-line= are two different
keys for very similar functionality. =comment-dwim-2= provides that
and a bit more. Sometimes indentation seems weird in elisp with
comments not lining up.

This is currently bugged with =enh-ruby-mode=. End of line comments
are not inserted, although it can successfully comment and uncomment
an entire line.

#+begin_src emacs-lisp
  (use-package comment-dwim-2
    :config
    (defadvice comment-indent (around comment-indent-with-spaces activate) ; Not the cause of enh-ruby-mode issue
      (let ((orig-indent-tabs-mode indent-tabs-mode))
        (when orig-indent-tabs-mode
          (setq indent-tabs-mode nil))
        ad-do-it
        (when orig-indent-tabs-mode
          (setq indent-tabs-mode t))))
    ;; Disabled for now. I want to remove line comment, keeping the
    ;; end of line comment unless I press M-; again.
    ;; Note though, text is killed, not deleted. You can always just
    ;; use C-e C-y to yank the text back at end of line
    ;; (defun cd2/inline-comment-command () ; this is the function called when you repeat the command
    ;;   ;; do nothing (not killing the end-of-line comment)
    ;;   (setq this-command nil) ; This is just a trick so that the command can still be called indefinitely
    ;;   )
    (define-key org-mode-map (kbd "M-;") 'org-comment-dwim-2)
    :bind ("M-;" . comment-dwim-2))
#+end_src


** Languages

*** Org

| =org=           | https://orgmode.org/                              |
| =org-superstar= | https://github.com/integral-dw/org-superstar-mode |

I use a more up-to-date version of Org than what Emacs ships with.
Currently =org-adapt-identation= does not work with ='headline-data=.
(At least, I haven't gotten it work successfully.) Tested 11/2020.

#+begin_src emacs-lisp
  (use-package org
    :mode (("\\.org$" . org-mode))
    :hook (org-mode . turn-on-auto-fill)  ; Don't make me spam M-q
    :config
    (setq org-log-done 'time)
    (setq org-adapt-indentation nil))
#+end_src

I enjoy colored bullets. I might remove
=org-superstar-leading-bullets= since it doesn't bother me too much
and doesn't seem to work anyway.

#+begin_src emacs-lisp
  (use-package org-superstar
    :hook (org-mode . org-superstar-mode)
    :config
    (org-superstar-configure-like-org-bullets) ; FIXME stars are still visible despite below line
    (setq org-superstar-leading-bullet ?\s))
#+end_src

*** Ruby

| =rbenv=    | https://github.com/senny/rbenv.el        |
| =inf-ruby= | https://github.com/nonsequitur/inf-ruby/ |
| =robe=     | https://github.com/dgutov/robe           |

=rbenv= for Emacs is 7 years old and unmainted. I'd like to replace it
sooner rather than later.

#+begin_src emacs-lisp
  (use-package rbenv
    :diminish
    :hook (ruby-mode . global-rbenv-mode))
#+end_src

=inf-ruby= is something I don't know how to use well yet. If you use
=irb= in =shell=, you will want the line =IRB.conf[:USE_MULTILINE] =
false= in =~/.config/irb/irbrc=, as otherwise you will just get
downward pointing arrows and no input or output.
Tested \approx 4/2020, didn't observe 11/2020 but may still be present.

[[https://github.com/nonsequitur/inf-ruby/issues/133][Here]] is a trick for guarding the IRB.conf clause so it won't impact
IRB sessions outside of Emacs. (Not tested thoroughly!)


#+begin_src emacs-lisp
  (use-package inf-ruby ; Latest version has --nomultline by default, but not for bundle console, only ruby
    :hook (ruby-mode . inf-ruby-minor-mode))
#+end_src

I really want to replace =robe= with =lsp-mode= and
=solargraph=. Having to run a full-blown interpreter seems overkill
and prone to errors.

#+begin_src emacs-lisp
  (use-package robe
    :defines company-backends
    :diminish
    :hook (enh-ruby-mode . robe-mode)
    :config (push 'company-robe company-backends))
#+end_src

*** YAML

| =yaml-mode= | https://github.com/yaml/yaml-mode |

Pretty much only one package for YAML.

#+begin_src emacs-lisp
  (use-package yaml-mode
    :mode "\\.yml\\'")
#+end_src


** Utilities

This is meant for utility packages that don't assist with editing,
navigation, or similar, but still provide a benefit.

*** Esup

| =Esup= | https://github.com/jschaf/esup |

Profile Emacs startup times with =M-x esup=. There's an apparent issue
with some combination of =straight=, =esup= and byte-compiling that
causes =Esup= to fail to run, either showing =Symbolic link to Git...=
or another error message. [[https://github.com/jschaf/esup/issues/54#issuecomment-651247749][This]] contains a fix.

It seems the fix isn't perfect, Esup is largely underestimating my
startup time. When I look in the breakdown, large sections of the code
are unaccounted for.

#+begin_src emacs-lisp
  (use-package esup
    :commands esup
    :config (setq esup-depth 0))
#+end_src

*** vterm

| =vterm= | https://github.com/akermu/emacs-libvterm |

A capable terminal emulator. This is compatible with =irb= multiline.
Projectile also supports creating a named vterm with =projectile-run-vterm=.

#+begin_src emacs-lisp
  (use-package vterm
    :commands vterm)
#+end_src

* List of TODOs

** TODO Move to solargrph and lsp-mode
** TODO move functions to :preface in =use-package=
** TODO Make an actual TODO list.
** DONE Alphabetize sensible defaults
CLOSED: [2020-11-10 Tue 14:49]
** DONE Some sort of solution to prevent needing to initialize straight in init
CLOSED: [2020-11-09 Mon 11:02]
Don't want to do that.
https://jonathanabennett.github.io/blog/2019/05/28/emacs.org-~-may-2019/
might have a solution with tangling.
** DONE Do we need straight in init.el?
CLOSED: [2020-11-09 Mon 11:02]
Any drawbacks from loading with old org version then upgrading?
** TODO Can we move speedup into =early-init.el=?
[[https://old.reddit.com/r/emacs/comments/dppmqj/do_i_even_need_to_leverage_earlyinitel_if_i_have/][This]] talks about how disabling certain decorations in early init is
faster. I'm curious how I can get org-tangle to export some code
blocks in one file and other code blocks in another file.

If I do this, I should set package-enable-at-startup to nil as well.

And loading org in early init wouldn't be a bad idea either.
** TODO Compatibility with tty
It had previous failed to load in a tty, complaining about listp nil.
I'm not reproducing the error now, just keep an eye out?

