#+TITLE: DotEmacs
#+AUTHOR: Richard Sent
#+PROPERTY: header-args :results silent

This is my personal Emacs configuration, now with 100% more =Org=!

* Installation

* List of TODOs

** TODO Move to solargraph and lsp-mode
** TODO move functions to :preface in =use-package=
** TODO Make an actual TODO list.
** TODO Alphabetize sensible defaults
** TODO Do we need straight in init.el?
Any drawbacks from loading with old org version then upgrading?


* Configuration

** Basics

*** Speedup

We want to keep the garbage collector from running while we initialize
everything. We can reset it later to a more reasonable value. If we
didn't do this, Emacs would hang when running the garbage collector.

#+begin_src emacs-lisp
  (setq-default
   gc-cons-threshold most-positive-fixnum ; 8 MiB
   gc-cons-percentage 0.6)
#+end_src

Replace the file-name-handler-alist to nil, as regexing is cpu
intensive. We need to keep the original value to restore it later. I
don't know all the details behind it, but it sounds helpful!

#+begin_src emacs-lisp
  (defvar default-file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)
#+end_src

And now we revert the changes with a startup hook. 16777216 is the
value Doom uses.

#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold 16777216
                    gc-cons-percentage 0.1
                    file-name-handler-alist default-file-name-handler-alist)))
#+end_src

Garbage-collect on focus-out. Emacs /should/ feel snappier overall.

#+BEGIN_SRC emacs-lisp
  (add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

*** Sensible Defaults

Don't randomly litter my filesystem with backups and autosaves.

#+begin_src emacs-lisp
  (setq
   backup-by-copying t                                  ; don't clobber symlinks
   backup-directory-alist                               ;
   `(("." . ,(concat user-emacs-directory "backups")))  ; don't litter my fs tree
   delete-old-versions t                                ;
   kept-new-versions 6                                  ;
   kept-old-versions 2                                  ;
   version-control t)                                   ; use versioned backups
#+end_src

I don't need no fancy user interface! These ones are only active when in a window.

#+begin_src emacs-lisp
    (when window-system
      (scroll-bar-mode 0)
      (tool-bar-mode 0)
      (tooltip-mode 0))
#+end_src

And now for a bunch of one liner configurations.

#+begin_src emacs-lisp
  (setq-default
   frame-resize-pixelwise t                      ; Removes empty space at bottom of screen when maximized
   inhibit-startup-screen t                      ; Emacs really could use a more "welcoming" welcome screen
   help-window-select t                          ; Select help windows when they appear
   initial-scratch-message ""                    ; Clear scratch buffer
   scroll-conservatively most-positive-fixnum    ; Always scroll by one line
   scroll-preserve-screen-position t             ; Try to keep point in the same location visually
   next-screen-context-lines 6                   ; Keep 6 lines of context when using scroll-up/down-command
   uniquify-buffer-name-style 'forward           ; Make buffer names unique
   show-help-function nil                        ; Disable help text on most UI elements
   sentence-end-double-space nil                 ; Use a single space after dots
   ring-bell-bunction 'ignore)                   ; My ears!
  (global-display-line-numbers-mode)             ; Show line numbers in all buffers
  (delete-selection-mode 1)                      ; If I selected something, I probably want to edit it.
  (global-auto-revert-mode 1)                    ; If I edit something elsewhere, I probably want to reload
  (global-hl-line-mode)                          ; Highlight the active line
  (defalias 'yes-or-no-p 'y-or-n-p)              ; y is shorter than yes
  (put 'downcase-region 'disabled nil)           ; Is it really that confusing?
  (put 'upcase-region 'disabled nil)             ; I reiterate. Is it really that confusing?
  (set-default-coding-systems 'utf-8)            ; Default to utf-8 encoding
#+end_src

Start Emacs in fullscreen.

#+BEGIN_SRC emacs-lisp
  (if (eq window-system 'ns)
      (set-frame-parameter nil 'fullscreen 'maximized)
    (set-frame-parameter nil 'fullscreen 'fullboth))
#+END_SRC

*** Support =custom.el=

I have no desire for autogenerated elisp to get appended to
=init.el=. I'd much rather concentrate that into a single file that I
call custom.el. Since I don't actually care about custom.el all that
much, I want to create a blank one if it doesn't already exist.

#+BEGIN_SRC emacs-lisp
  (write-region "" "" (expand-file-name "custom.el" (file-name-directory (or load-file-name buffer-file-name))) t)
  (setq-default custom-file (expand-file-name "custom.el" (file-name-directory (or load-file-name buffer-file-name))))
  (load custom-file)
#+END_SRC

*** Constants
A slowly growing list of constants. [[https://github.com/seagle0128/.emacs.d][Centaur Emacs]] has a comprehensive
list that I haven't ~stolen~ proactively borrowed yet.

#+begin_src emacs-lisp
  (defconst sys/win32p                    ; Boy, I hope I don't need this constant
    (eq system-type 'windows-nt)
    "Are we running on a WinTel system?")
#+end_src

*** Straight Bootstrap
I use [[https://github.com/raxod502/straight.el][straight.el]] for package management. This is boostrap code from
the Github repo to set up straight.

I wrapped it in an =eval-and-compile= because =flycheck= thought every
variable I configured in =use-package= didn't exist. Credit to
[[https://reddit.com/r/emacs/comments/gwupwt/noob_please_help_to_resolve_the_flycheck_error/ft1kk2j/][/u/cpitclaudel]] on Reddit for the solution! It's not perfect; functions
are still recognized as undefined, but at least that is condensed into
one warning at the end.

#+begin_src emacs-lisp
  ;; (eval-and-compile
  ;;   (defvar straight-fix-flycheck t)
  ;;   (defvar bootstrap-version)
  ;;   (let ((bootstrap-file
  ;;          (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
  ;;         (bootstrap-version 5))
  ;;     (unless (file-exists-p bootstrap-file)
  ;;       (with-current-buffer
  ;;           (url-retrieve-synchronously
  ;;            "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
  ;;            'silent 'inhibit-cookies)
  ;;         (goto-char (point-max))
  ;;         (eval-print-last-sexp)))
  ;;     (load bootstrap-file nil 'nomessage))
  ;;   (straight-use-package 'use-package))      ; Install use-package
  ;; (setq straight-use-package-by-default t)    ; I don't want to type :straight t a billion times
#+end_src


** Functions
Custom functions from various sources that I use later on in the init file.

Return t if a font is installed, nil otherwise.
#+begin_src emacs-lisp
  (defun aorst/font-installed-p (font-name)
    "Check if font with FONT-NAME is available."
    (if (find-font (font-spec :name font-name))
        t
      nil))
#+end_src

A duo of functions for getting human readable file sizes.
#+begin_src emacs-lisp
  (defun ajv/human-readable-file-sizes-to-bytes (string)
    "Convert a human-readable file size into bytes."
    (interactive)
    (cond
     ((string-suffix-p "G" string t)
      (* 1000000000 (string-to-number (substring string 0 (- (length string) 1)))))
     ((string-suffix-p "M" string t)
      (* 1000000 (string-to-number (substring string 0 (- (length string) 1)))))
     ((string-suffix-p "K" string t)
      (* 1000 (string-to-number (substring string 0 (- (length string) 1)))))
     (t
      (string-to-number (substring string 0 (- (length string) 1))))
     )
    )
  (defun ajv/bytes-to-human-readable-file-sizes (bytes)
    "Convert number of bytes to human-readable file size."
    (interactive)
    (cond
     ((> bytes 1000000000) (format "%10.1fG" (/ bytes 1000000000.0)))
     ((> bytes 100000000) (format "%10.0fM" (/ bytes 1000000.0)))
     ((> bytes 1000000) (format "%10.1fM" (/ bytes 1000000.0)))
     ((> bytes 100000) (format "%10.0fk" (/ bytes 1000.0)))
     ((> bytes 1000) (format "%10.1fk" (/ bytes 1000.0)))
     (t (format "%10d" bytes)))
    )
#+end_src


** UI

*** Icons

| =all-the-icons=       | https://github.com/domtronn/all-the-icons.el  |
| =all-the-icons-dired= | https://github.com/jtbm37/all-the-icons-dired |

I like having pretty icons next to a lot of things. I also don't like
remembering to install them on a new machine.


#+begin_src emacs-lisp
  (use-package all-the-icons
    :config
    (when (and (not (aorst/font-installed-p "all-the-icons"))
               (window-system))
      (all-the-icons-install-fonts t))
    :defer 1)
#+end_src

I also like having them in dired.

#+begin_src emacs-lisp
  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

*** Themes

| =doom-themes= | https://github.com/hlissner/emacs-doom-themes |

Why install one theme when many will do? Yeah, that sounds right.

#+begin_src emacs-lisp
  (use-package doom-themes
    :config (load-theme 'doom-nord t))
#+end_src

*** Font

Larger than the normal font.

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :height 110)
#+end_src

*** Ibuffer

| =all-the-icons-ibuffer= | https://github.com/seagle0128/all-the-icons-ibuffer |
| =ibuffer-vc=            | https://github.com/purcell/ibuffer-vc               |

First and foremost, replace =list-buffers= with =ibuffer=

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

Next, I'll set up some pretty icons.

#+begin_src emacs-lisp
  (use-package all-the-icons-ibuffer
    :diminish
    :after all-the-icons)
#+end_src

Time to actually make it functional by setting up automatic version
control groups.

#+begin_src emacs-lisp
  (use-package ibuffer-vc ; Also consider ibuffer-projectile
    :after all-the-icons-ibuffer
    :hook (ibuffer . (lambda () (ibuffer-vc-set-filter-groups-by-vc-root) ; Look at combining with custom ibuffer groups with 'ibffuer-projectile-generate-filter-groups
                       (unless (eq ibuffer-sorting-mode 'alphabetic)      ; Obviously that's an ibuffer-projectile exclusive, not ibuffer-vc
                         (ibuffer-do-sort-by-alphabetic))))               ; https://emacs.stackexchange.com/questions/2181/ibuffer-how-to-automatically-create-groups-per-project
    :bind ("C-x C-b" . ibuffer)                                           ; shows some of code behind projectile filter groups
    :config
    (define-ibuffer-column size-h
      (:name "Size"
             :inline t
             :summarizer
             (lambda (column-strings)
               (let ((total 0))
                 (dolist (string column-strings)
                   (setq total
                         ;; like, ewww ...
                         (+ (float (ajv/human-readable-file-sizes-to-bytes string))
                            total)))
                 (ajv/bytes-to-human-readable-file-sizes total)))  ;; :summarizer nil
             )
      (ajv/bytes-to-human-readable-file-sizes (buffer-size)))
    (setq ibuffer-formats
          '((mark modified read-only vc-status-mini " "
                  (icon 2 2 :center :elide)
                  " "
                  (name 18 18 :left :elide)
                  " "
                  (size-h 9 -1 :right)
                  " "
                  (mode 20 20 :left :elide)
                  " "
                  (vc-status 16 16 :left)
                  " "
                  vc-relative-file))))
#+end_src

*** Which-key

| =which-key= | https://github.com/justbur/emacs-which-key |

Emacs has a lot of keybindings. I can't remember every keybinding. I
use a tool to remember every keybinding for me.

#+begin_src emacs-lisp
  (use-package which-key
    :defer 1
    :diminish
    :config (which-key-mode)
    (setq which-key-add-column-padding 3)) ; Easier to visually seperate columns
#+end_src

*** Modeline

| =doom-modeline= | https://github.com/seagle0128/doom-modeline |
| =diminish=      | https://github.com/emacsmirror/diminish     |

Since I haven't gotten around to customizing my modeline yet, I just
use =doom-modeline=.

#+begin_src emacs-lisp
  (use-package doom-modeline ; Later, replace with custom following similar process to https://www.gonsie.com/blorg/modeline.html
    :hook (after-init . doom-modeline-mode)
    :custom                               ; Could use more use-package-ifying
    (doom-modeline-height 20)             ; To better employ its features.
    (doom-modeline-bar-width 1)
    (doom-modeline-icon t)
    (doom-modeline-major-mode-icon t)
    (doom-modeline-major-mode-color-icon t)
    (doom-modeline-buffer-file-name-style 'truncate-upto-project)
    (doom-modeline-buffer-state-icon t)
    (doom-modeline-buffer-modification-icon t)
    (doom-modeline-minor-modes nil)
    (doom-modeline-enable-word-count nil)
    (doom-modeline-buffer-encoding t)
    (doom-modeline-indent-info nil)
    (doom-modeline-checker-simple-format t)
    (doom-modeline-vcs-max-length 12)
    (doom-modeline-env-version t)
    (doom-modeline-irc-stylize 'identity)
    (doom-modeline-github-timer nil)
    (doom-modeline-gnus-timer nil))
#+end_src

To help me when I actually do customize the modeline myself, I'll have
=diminish= to hide my active minor modes.

#+begin_src emacs-lisp
  (use-package diminish)
#+end_src


** Navigation

*** Ivy

| =ivy=                    | https://github.com/abo-abo/swiper                    |
| =counsel=                | https://github.com/abo-abo/swiper                    |
| =swiper=                 | https://github.com/abo-abo/swiper                    |
| =counsel-projectile=     | https://github.com/ericdanan/counsel-projectile      |
| =ivy-rich=               | https://github.com/Yevgnen/ivy-rich                  |
| =all-the-icons-ivy-rich= | https://github.com/seagle0128/all-the-icons-ivy-rich |

Let's start with the backbone of it all, =ivy=. It helps provide a
completion engine that =counsel= and =swiper= build off of. 

#+begin_src emacs-lisp
  (use-package ivy
    :diminish
    :defer 1
    :config
    (setq ivy-use-virtual-buffers t       ; Recent files and bookmarks in ivy-switch-buffer
          ivy-count-format "%d/%d ")
    (setq ivy-wrap t)                     ; Wrap around with next-line and previous-line
    (ivy-mode 1))
#+end_src

=counsel= provides many custom functions designed to take advantage of
ivy, such as =counsel-find-file=.

#+begin_src emacs-lisp
  (use-package counsel
    :diminish
    :after ivy
    :config (counsel-mode))
#+end_src

=swiper= is an =isearch= alternative, which is good because I don't
like =isearch=.

#+begin_src emacs-lisp
  (use-package swiper
    :after ivy
    :bind (("C-s" . swiper)
           ("C-r" . swiper)))
#+end_src

=counsel-projectile= provides integration between the two tools.

#+begin_src emacs-lisp
  (use-package counsel-projectile
    :after (counsel projectile)
    :functions counsel-projectile-mode
    :config (counsel-projectile-mode))
#+end_src

=ivy-rich= makes things look purdy.

#+begin_src emacs-lisp
  (use-package ivy-rich
    :functions ivy-rich-mode
    :after ivy counsel
    :config (ivy-rich-mode 1)
    (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)) ; Recommended in Github repo
#+end_src

=all-the-icons-ivy-rich= makes the purdy thing look purdy.

#+begin_src emacs-lisp
  (use-package all-the-icons-ivy-rich
    :after all-the-icons ivy-rich
    :functions all-the-icons-ivy-rich-mode
    :config (all-the-icons-ivy-rich-mode 1))
#+end_src

*** Projectile

| =projectile= | https://github.com/bbatsov/projectile |

#+begin_src emacs-lisp
  (use-package projectile
    :functions projectile-mode
    :diminish
    :config (projectile-mode +1)
    :bind-keymap ("C-c p" . projectile-command-map))
#+end_src

*** Window Management

| =ace-window= | https://github.com/abo-abo/ace-window |

Running =other-window= a billion times isn't exactly enjoyable. What
is enjoying is executing =ace-window= once and typing 1-2 keys to
select a window.

Instead of 0-9, =ace-window= will use the home row keys to select a
window.

#+begin_src emacs-lisp
  (use-package ace-window
    :defines aw-keys
    :functions ace-window
    :bind* ("M-o" . 'ace-window) ; * as ibuffer overrides M-o. Consider adjusting as M-o is used for ivy-dispatching done
    :config (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+end_src


** Editing

This section is for non-language-specific customizations that still
help with editing.

*** Parentheses

| =highlight-parentheses= | https://github.com/tsdh/highlight-parentheses.el |
| =smartparens=           | https://github.com/Fuco1/smartparens             |

Apparently =rainbow-delimiters= provides similar functionality to
=highlight-parentheses=, I'll look into it later.

#+begin_src emacs-lisp
  (use-package highlight-parentheses
    :diminish
    :hook (prog-mode . highlight-parentheses-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package smartparens
    :diminish
    :hook (prog-mode . smartparens-mode)
    :config (require 'smartparens-config))
#+end_src

*** wgrep

| =wrep= | https://github.com/mhayashi1120/Emacs-wgrep |

#+begin_src emacs-lisp
  (use-package wgrep
    :defer 1)
#+end_src

*** Company

| =company= | https://github.com/company-mode/company-mode |

A text-completion framework. Would like to replace RET with C-j like
=ivy=.

#+begin_src emacs-lisp
  (use-package company
    :defines company-minimum-prefix-length company-frontends company-idle-delay
    :diminish
    :hook (prog-mode . company-mode)
    :config
    (setq company-minimum-prefix-length 1)
    (setq company-frontends '(company-pseudo-tooltip-frontend
                              company-echo-metadata-frontend))
    (setq company-idle-delay 1))
#+end_src

*** Flycheck

| =flycheck= | https://github.com/flycheck/flycheck |

Syntax checking for Emacs.

#+begin_src emacs-lisp
  (use-package flycheck
    :functions global-flycheck-mode
    :diminish
    :defer 1
    :config (setq flycheck-emacs-lisp-load-path 'inherit)  ; Fixes "org-mode-map" in comment-dwin-2 from being undefined
    (global-flycheck-mode))                                ; Does not fix issues with functions may not be defined
#+end_src

*** Comments

| =comment-dwim-2= | https://github.com/remyferre/comment-dwim-2 |

I don't enjoy how =comment-dwim= and =comment-line= are two different
keys for very similar functionality. =comment-dwim-2= provides that
and a bit more. Sometimes indentation seems weird in elisp with
comments not lining up.

This is currently bugged with =enh-ruby-mode=. End of line comments
are not inserted, although it can successfully comment and uncomment
an entire line.

#+begin_src emacs-lisp
  (use-package comment-dwim-2                          ; FIXME: Bug with enh-ruby-mode. No end of line comments
                                          ; are inserted. ruby-mode does not have this issue. Will
    :config                                            ; look more into what's causing it.
    (defadvice comment-indent (around comment-indent-with-spaces activate) ; Not the cause of enh-ruby-mode issue
      (let ((orig-indent-tabs-mode indent-tabs-mode))
        (when orig-indent-tabs-mode
          (setq indent-tabs-mode nil))
        ad-do-it
        (when orig-indent-tabs-mode
          (setq indent-tabs-mode t))))
    ;; Disabled for now. I want to remove line comment, keeping the
    ;; end of line comment unless I press M-; again.
    ;; Note though, text is killed, not deleted. You can always just
    ;; use C-e C-y to yank the text back at end of line
    ;; (defun cd2/inline-comment-command () ; this is the function called when you repeat the command
    ;;   ;; do nothing (not killing the end-of-line comment)
    ;;   (setq this-command nil) ; This is just a trick so that the command can still be called indefinitely
    ;;   )
    (define-key org-mode-map (kbd "M-;") 'org-comment-dwim-2)
    :bind ("M-;" . comment-dwim-2))
#+end_src

* Languages

** Org

| =org=           | https://orgmode.org/                              |
| =org-superstar= | https://github.com/integral-dw/org-superstar-mode |

I want to use a more up-to-date version of Org than what Emacs ships
with. Currently =org-adapt-identation= does not work with
='headline-data=. (At least, I haven't gotten it work successfully.)
Tested 11 2020.

#+begin_src emacs-lisp
  (use-package org
    :mode (("\\.org$" . org-mode))
    :config
    (setq org-log-done 'time)
    (setq org-adapt-indentation nil))
#+end_src

I enjoy colored bullets. I might remove the
=org-superstar-leading-bullets= since it doesn't bother me too much
and doesn't work anyway it seems.

#+begin_src emacs-lisp
  (use-package org-superstar
    :hook (org-mode . org-superstar-mode)
    :config
    (org-superstar-configure-like-org-bullets) ; FIXME stars are still visible despite below line
    (setq org-superstar-leading-bullet ?\s))
#+end_src

** Ruby

| =rbenv=    | https://github.com/senny/rbenv.el        |
| =inf-ruby= | https://github.com/nonsequitur/inf-ruby/ |
| =robe=     | https://github.com/dgutov/robe           |

=rbenv= for Emacs is 7 years old and unmainted. I'd like to replace it
sooner rather than later.

#+begin_src emacs-lisp
  (use-package rbenv
    :diminish
    :hook (ruby-mode . global-rbenv-mode))
#+end_src

=inf-ruby= is something I don't know how to use well yet. If you use
=irb= in =shell=, you will want the line =IRB.conf[:USE_MULTILINE] =
false= in =~/.config/irb/irbrc=, as otherwise you will just get
downward pointing arrows and no input or output.
Tested \approx 4/2020, didn't observe 11/2020 but may still be present.

[[https://github.com/nonsequitur/inf-ruby/issues/133][Here]] is a trick for guarding the IRB.conf clause so it won't impact
IRB sessions outside of Emacs. (Not tested thoroughly!)


#+begin_src emacs-lisp
  (use-package inf-ruby ; Latest version has --nomultline by default, but not for bundle console, only ruby
    :hook (ruby-mode . inf-ruby-minor-mode))
#+end_src

I really want to replace =robe= with =lsp-mode= and
=solargraph=. Having to run a full-blown interpreter seems overkill
and prone to errors.

#+begin_src emacs-lisp
  (use-package robe
    :defines company-backends
    :diminish
    :hook (enh-ruby-mode . robe-mode)
    :config (push 'company-robe company-backends))
#+end_src

** YAML

| =yaml-mode= | https://github.com/yaml/yaml-mode |

Pretty much only one package for YAML.

#+begin_src emacs-lisp
  (use-package yaml-mode
    :mode "\\.yml\\'")
#+end_src
